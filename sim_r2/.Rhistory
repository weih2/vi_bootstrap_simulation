main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(diagXTX * (1 - beta.posterior$phi)) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(diagXTX * (1 - beta.posterior$phi)) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
1/c(1,2,3)
# slower version
update.A = function(){
solve(
XTX %*% diag(beta.posterior$phi) + diagXTX %*% diag(1 - beta.posterior$phi)
+ diag(n.pars)/nu1
)
}
solve(
XTX %*% diag(beta.posterior$phi) + diagXTX %*% diag(1 - beta.posterior$phi)
+ diag(n.pars)/nu1
)
# slower version
update.A = function(beta.posterior){
solve(
XTX %*% diag(beta.posterior$phi) + diagXTX %*% diag(1 - beta.posterior$phi)
+ diag(n.pars)/nu1
)
}
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
# inv.A = update.A(inv.A, active.set, B, D)
inv.A = update.A(beta,posterior)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
# inv.A = update.A(inv.A, active.set, B, D)
inv.A = update.A(beta.posterior)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
# slower version
update.A = function(beta.posterior){
solve(
XTX %*% diag(beta.posterior$phi) + diag(diagXTX %*% (1 - beta.posterior$phi))
+ diag(n.pars)/nu1
)
}
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
# inv.A = update.A(inv.A, active.set, B, D)
# inv.A = update.A(beta.posterior)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
update.A = function(inv.A, active.set, B, D){
inv.A = inv.A - inv.A %*% B[, active.set] %*%
solve(diag(1/D[active.set]) + inv.A[active.set, ] %*% B[, active.set]) %*%
inv.A[active.set, ]
return(inv.A)
}
main.loop()
auto.cor = 0.01 # collinearity
data = gen.everything()
XTX = t(data$X) %*% (data$X)
diagXTX = diag(XTX)
XTy = t(data$X) %*% (data$y)
main.loop()
auto.cor = 0.00 # collinearity
data = gen.everything()
XTX = t(data$X) %*% (data$X)
diagXTX = diag(XTX)
XTy = t(data$X) %*% (data$y)
warings()
warnings()
data = gen.everything()
auto.cor = 0.001 # collinearity
# generate one observation
gen.one.obs = function(o){
as.numeric(
arima.sim(
list(c(1,0,0), # ar(1) model
ar = auto.cor),
n = n.pars
)
)
}
# generate all observations
gen.all.obs = function(o){
sapply(1:n.obs, gen.one.obs)
}
# arrange all observations
create.design.matrix = function(o){
t(gen.all.obs())
}
# generate y, put x and y into the same object
gen.everything = function(){
X = create.design.matrix()
noise = rnorm(n.obs, sd = sqrt(sigma2))
y = X %*% beta + noise
return(list(X = X, y = y))
}
data = gen.everything()
XTX = t(data$X) %*% (data$X)
diagXTX = diag(XTX)
XTy = t(data$X) %*% (data$y)
main.loop()
# generate one observation
gen.one.obs = function(o){
if(auto.cor != 0)
as.numeric(
arima.sim(
list(c(1,0,0), # ar(1) model
ar = auto.cor),
n = n.pars
)
)else
rnorm(n.pars)
}
auto.cor = 0.00 # collinearity
data = gen.everything()
XTX = t(data$X) %*% (data$X)
diagXTX = diag(XTX)
XTy = t(data$X) %*% (data$y)
main.loop()
update.A.slow = function(beta.posterior){
return(
solve(
XTX %*% diag(beta.posterior$phi) + diag(diagXTX * (1 - beta.posterior$phi)) +
diag(n.pars)/nu1
)
)
}
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
print(inv.A)
print(update.A.slow(beta.posterior))
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diagXTX
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
inv.A = update.A.slow(beta.posterior)
print(inv.A)
print(update.A.slow(beta.posterior))
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diag(diagXTX)
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
inv.A = update.A.slow(beta.posterior)
print(inv.A)
print(update.A.slow(beta.posterior))
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diag(diagXTX)
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
print(
list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
)
)
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop
main.loop()
# main loop
main.loop = function(o){
beta.posterior = init.beta.posterior()
global.posterior = init.global.posterior()
new_entropy = rep(0, n.pars)
active.set = rep(TRUE, n.pars)
inv.A = solve(
XTX %*% diag(beta.posterior$phi) + diag(n.pars)/nu1
)
D = numeric(n.pars)
B = XTX - diag(diagXTX)
repeat{
entropy = new_entropy
D = - (beta.posterior$phi)
beta.posterior = cavi.estimate(beta.posterior, global.posterior, inv.A, active.set)
global.posterior = em.estimate(beta.posterior, global.posterior)
D = D + (beta.posterior$phi)
# exclude probabilities close to 0 or 1 from iteration
active.set = ((beta.posterior$phi > prob.threshold) &
(beta.posterior$phi < 1 - prob.threshold))
if(sum(active.set) == 0) break
inv.A = update.A(inv.A, active.set, B, D)
new_entropy = cal.entropy(beta.posterior$phi, active.set)
if(max(abs(new_entropy - entropy)) < epsilon) break
}
return(list(
beta.posterior = beta.posterior,
global.posterior = global.posterior
))
}
main.loop()
