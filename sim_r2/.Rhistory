install.packages("ggplot2")
library(Rcpp)
show(covered)
contributors()
qnorm(0.975)
sd(\)
sd()
help(sd)
get.beta1.vwlb.cs = function(confidence){
beta1.point.estimate = main.loop()$beta.posterior$mu[1]
beta1.bootstrap.map = numeric(0)
for(i in 1:n.b.samples){
weights = gen.weights()
data.X <<- diag(sqrt(weights)) %*% original.data$X
data.y <<- diag(sqrt(weights)) %*% original.data$y
XTX <<- t(original.data$X) %*% diag(weights) %*% original.data$X
diagXTX <<- diag(XTX)
XTy <<- t(original.data$X) %*% diag(weights) %*% original.data$y
beta1.bootstrap.map = c(beta1.bootstrap.map,
main.loop()$beta.posterior$mu[1])
}
vwlb.ci1 = c(
quantile(beta1.bootstrap.map, (1 - confidence)/2),
quantile(beta1.bootstrap.map, (1 + confidence)/2)
)
vwlb.ci1 = 2 * beta1.point.estimate - vwlb.ci1
vwlb.ci2 = c(
mean(beta1.bootstrap.map) - sd(beta1.bootstrap.map) * qnorm(0.975),
mean(beta1.bootstrap.map) + sd(beta1.bootstrap.map) * qnorm(0.975)
)
return(
list(
vwlb.ci1 = vwlb.ci1,
vwlb.ci2 = vwlb.ci2
)
)
# return(beta1.bootstrap.map)
}
covered = 0
for(i in 1:n.experiments){
original.data <<- gen.new.y(original.data)
if(i %% 10 == 0) print(i)
vwlb.cs = get.beta1.vwlb.cs(0.95)$vwlb.cs1
# print(vwlb.cs[1]); print(vwlb.cs[2])
if(
(vwlb.cs[1] < beta[1])&
(vwlb.cs[2] > beta[1])
) covered = covered + 1
}
source("point_estimate.R")
setwd("~/Projects/vi_bootstrap_simulation/sim_r2")
source("point_estimate.R")
n.experiments = 100
n.b.samples = 500
original.data = data
get.beta1.vwlb.cs = function(confidence){
beta1.point.estimate = main.loop()$beta.posterior$mu[1]
beta1.bootstrap.map = numeric(0)
for(i in 1:n.b.samples){
weights = gen.weights()
data.X <<- diag(sqrt(weights)) %*% original.data$X
data.y <<- diag(sqrt(weights)) %*% original.data$y
XTX <<- t(original.data$X) %*% diag(weights) %*% original.data$X
diagXTX <<- diag(XTX)
XTy <<- t(original.data$X) %*% diag(weights) %*% original.data$y
beta1.bootstrap.map = c(beta1.bootstrap.map,
main.loop()$beta.posterior$mu[1])
}
vwlb.ci1 = c(
quantile(beta1.bootstrap.map, (1 - confidence)/2),
quantile(beta1.bootstrap.map, (1 + confidence)/2)
)
vwlb.ci1 = 2 * beta1.point.estimate - vwlb.ci1
vwlb.ci2 = c(
mean(beta1.bootstrap.map) - sd(beta1.bootstrap.map) * qnorm(0.975),
mean(beta1.bootstrap.map) + sd(beta1.bootstrap.map) * qnorm(0.975)
)
return(
list(
vwlb.ci1 = vwlb.ci1,
vwlb.ci2 = vwlb.ci2
)
)
# return(beta1.bootstrap.map)
}
covered = 0
for(i in 1:n.experiments){
original.data <<- gen.new.y(original.data)
if(i %% 10 == 0) print(i)
vwlb.cs = get.beta1.vwlb.cs(0.95)$vwlb.cs1
# print(vwlb.cs[1]); print(vwlb.cs[2])
if(
(vwlb.cs[1] < beta[1])&
(vwlb.cs[2] > beta[1])
) covered = covered + 1
}
show(covered)
get.beta1.vwlb.cs(0.95)$vwlb.cs1
get.beta1.vwlb.cs(0.95)$vwlb.ci1
for(i in 1:n.experiments){
original.data <<- gen.new.y(original.data)
if(i %% 10 == 0) print(i)
vwlb.cs = get.beta1.vwlb.cs(0.95)$vwlb.ci1
# print(vwlb.cs[1]); print(vwlb.cs[2])
if(
(vwlb.cs[1] < beta[1])&
(vwlb.cs[2] > beta[1])
) covered = covered + 1
}
show(covered)
main.loop()$beta.posterior$mu[1]
get.beta1.vwlb.cs = function(confidence){
beta1.point.estimate = main.loop()$beta.posterior$mu[1]
beta1.bootstrap.map = numeric(0)
for(i in 1:n.b.samples){
weights = gen.weights()
data.X <<- diag(sqrt(weights)) %*% original.data$X
data.y <<- diag(sqrt(weights)) %*% original.data$y
XTX <<- t(original.data$X) %*% diag(weights) %*% original.data$X
diagXTX <<- diag(XTX)
XTy <<- t(original.data$X) %*% diag(weights) %*% original.data$y
beta1.bootstrap.map = c(beta1.bootstrap.map,
main.loop()$beta.posterior$mu[1])
}
vwlb.ci1 = c(
quantile(beta1.bootstrap.map, (1 + confidence)/2),
quantile(beta1.bootstrap.map, (1 - confidence)/2)
)
vwlb.ci1 = 2 * beta1.point.estimate - vwlb.ci1
vwlb.ci2 = c(
mean(beta1.bootstrap.map) - sd(beta1.bootstrap.map) * qnorm(0.975),
mean(beta1.bootstrap.map) + sd(beta1.bootstrap.map) * qnorm(0.975)
)
return(
list(
vwlb.ci1 = vwlb.ci1,
vwlb.ci2 = vwlb.ci2
)
)
# return(beta1.bootstrap.map)
}
covered = 0
for(i in 1:n.experiments){
original.data <<- gen.new.y(original.data)
if(i %% 10 == 0) print(i)
vwlb.cs = get.beta1.vwlb.cs(0.95)$vwlb.ci1
# print(vwlb.cs[1]); print(vwlb.cs[2])
if(
(vwlb.cs[1] < beta[1])&
(vwlb.cs[2] > beta[1])
) covered = covered + 1
}
show(covered)
source("point_estimate.R")
covered = 0
for(i in 1:n.experiments){
original.data <<- gen.new.y(original.data)
if(i %% 10 == 0) print(i)
vwlb.cs = get.beta1.vwlb.cs(0.95)$vwlb.ci1
# print(vwlb.cs[1]); print(vwlb.cs[2])
if(
(vwlb.cs[1] < beta[1])&
(vwlb.cs[2] > beta[1])
) covered = covered + 1
}
show(covered)
get.beta1.vwlb.cs(0.95)$vwlb.ci1
main.loop()$beta.posterior$mu[1]
get.beta1.vwlb.cs = function(original.data, confidence){
XTX <<- t(original.data$X) %*% (original.data$X)
diagXTX <<- diag(XTX)
XTy <<- t(original.data$X) %*% (original.data$y)
beta1.point.estimate = main.loop()$beta.posterior$mu[1]
beta1.bootstrap.map = numeric(0)
for(i in 1:n.b.samples){
weights = gen.weights()
data.X <<- diag(sqrt(weights)) %*% original.data$X
data.y <<- diag(sqrt(weights)) %*% original.data$y
XTX <<- t(original.data$X) %*% diag(weights) %*% original.data$X
diagXTX <<- diag(XTX)
XTy <<- t(original.data$X) %*% diag(weights) %*% original.data$y
beta1.bootstrap.map = c(beta1.bootstrap.map,
main.loop()$beta.posterior$mu[1])
}
vwlb.ci1 = c(
quantile(beta1.bootstrap.map, (1 + confidence)/2),
quantile(beta1.bootstrap.map, (1 - confidence)/2)
)
vwlb.ci1 = 2 * beta1.point.estimate - vwlb.ci1
vwlb.ci2 = c(
mean(beta1.bootstrap.map) - sd(beta1.bootstrap.map) * qnorm(0.975),
mean(beta1.bootstrap.map) + sd(beta1.bootstrap.map) * qnorm(0.975)
)
return(
list(
vwlb.ci1 = vwlb.ci1,
vwlb.ci2 = vwlb.ci2
)
)
# return(beta1.bootstrap.map)
}
covered = 0
original.data = data
for(i in 1:n.experiments){
original.data = gen.new.y(original.data)
if(i %% 10 == 0) print(i)
vwlb.cs = get.beta1.vwlb.cs(original.data, 0.95)$vwlb.ci1
# print(vwlb.cs[1]); print(vwlb.cs[2])
if(
(vwlb.cs[1] < beta[1])&
(vwlb.cs[2] > beta[1])
) covered = covered + 1
}
show(covered)
help(pnorm)
vb.beta1.credential.set = function(beta.posterior, confidence){
# remaining prob excluding the point mass at 0
re.prob = confidence - 1 + beta.posterior$phi[1]
if(re.prob < 0) return(c(0,0))
# posterior (beta < 0)
posterior.nagetive =
pnorm( - (beta.posterior$mu[1])/sqrt(beta.posterior$s2[1]))
if(2 * posterior.nagetive < 1 - re.prob){
return(
c(0,
pnorm(1 - re.prob - posterior.nagetive,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])))
)
}
if(2 - 2 * posterior.nagetive < 1 - re.prob){
return(
c( pnorm( posterior.nagetive - re.prob,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])
),
0)
)
}
# quantile standard normal
q.std = qnorm((1 + re.prob)/2)
return(c(
beta.posterior$mu - q.std * sqrt(beta.posterior$s2[1]),
beta.posterior$mu + q.std * sqrt(beta.posterior$s2[1])
)
)
}
vb.beta1.credential.set(main.loop()$beta.posterior, 0.95)
vb.beta1.credential.set(main.loop()$beta.posterior, 0.95)
main.loop()$beta.posterior$phi
vb.beta1.credential.set = function(beta.posterior, confidence){
# remaining prob excluding the point mass at 0
re.prob = confidence - 1 + beta.posterior$phi[1]
if(re.prob < 0) return(c(0,0))
# posterior (beta < 0)
posterior.nagetive =
pnorm( - (beta.posterior$mu[1])/sqrt(beta.posterior$s2[1]))
if(2 * posterior.nagetive < 1 - re.prob){
return(
c(0,
pnorm( re.prob + posterior.nagetive,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])))
)
}
if(2 - 2 * posterior.nagetive < 1 - re.prob){
return(
c( pnorm( posterior.nagetive - re.prob,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])
),
0)
)
}
# quantile standard normal
q.std = qnorm((1 + re.prob)/2)
return(c(
beta.posterior$mu - q.std * sqrt(beta.posterior$s2[1]),
beta.posterior$mu + q.std * sqrt(beta.posterior$s2[1])
)
)
}
vb.beta1.credential.set(main.loop()$beta.posterior, 0.95)
vb.beta1.credential.set = function(beta.posterior, confidence){
# remaining prob excluding the point mass at 0
re.prob = confidence - 1 + beta.posterior$phi[1]
if(re.prob < 0) return(c(0,0))
# posterior (beta < 0)
posterior.nagetive =
pnorm( - (beta.posterior$mu[1])/sqrt(beta.posterior$s2[1]))
show(posterior.nagetive)
if(2 * posterior.nagetive < 1 - re.prob){
return(
c(0,
pnorm( re.prob + posterior.nagetive,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])))
)
}
if(2 - 2 * posterior.nagetive < 1 - re.prob){
return(
c( pnorm( posterior.nagetive - re.prob,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])
),
0)
)
}
# quantile standard normal
q.std = qnorm((1 + re.prob)/2)
return(c(
beta.posterior$mu - q.std * sqrt(beta.posterior$s2[1]),
beta.posterior$mu + q.std * sqrt(beta.posterior$s2[1])
)
)
}
vb.beta1.credential.set(main.loop()$beta.posterior, 0.95)
vb.beta1.credential.set = function(beta.posterior, confidence){
# remaining prob excluding the point mass at 0
re.prob = confidence - 1 + beta.posterior$phi[1]
if(re.prob < 0) return(c(0,0))
# posterior (beta < 0)
posterior.nagetive =
pnorm( - (beta.posterior$mu[1])/sqrt(beta.posterior$s2[1]))
if(2 * posterior.nagetive < 1 - re.prob){
return(
c(0,
qnorm( re.prob + posterior.nagetive,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])))
)
}
if(2 - 2 * posterior.nagetive < 1 - re.prob){
return(
c( qnorm( posterior.nagetive - re.prob,
mean = beta.posterior$mu[1],
sd = sqrt(beta.posterior$s2[1])
),
0)
)
}
# quantile standard normal
q.std = qnorm((1 + re.prob)/2)
return(c(
beta.posterior$mu - q.std * sqrt(beta.posterior$s2[1]),
beta.posterior$mu + q.std * sqrt(beta.posterior$s2[1])
)
)
}
vb.beta1.credential.set(main.loop()$beta.posterior, 0.95)
vb.beta1.credential.set(main.loop()$beta.posterior, 0.95)
vb.beta1.credential.set(main.loop()$beta.posterior, 0.95)
main.loop()$beta.posterior
